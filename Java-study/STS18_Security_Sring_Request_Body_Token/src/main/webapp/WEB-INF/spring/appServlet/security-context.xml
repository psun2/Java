<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:security="http://www.springframework.org/schema/security"
       xsi:schemaLocation="http://www.springframework.org/schema/security
		http://www.springframework.org/schema/security/spring-security-5.3.xsd
		http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans.xsd">


    <security:http>
        <!-- pattern : url pattern , access : 접근 권한 -->
        <security:intercept-url pattern="/" access="permitAll()"/>
        <!--<security:intercept-url pattern="/" access="hasRole('ROLE_ADMIN')"/>-->

        <security:access-denied-handler/>
        <!--
        USER ROLE 가진 사람이
        ADMIN ROLE 을 부여받은 URL 에 접근하려 할때
        접근 권한 handeler
        <security:access-denied-handler
                ref="AccessDeniedHandler 객체를 상속 받아 Bean으로 등록"
                error-page="에러페이지 URL"/>
        -->

        <security:form-login/> <!-- spring security 가 제공하는 기본 로그인 폼 -->
        <!--
        <security:form-login login-page="내가만든 login form 페이지 URL"
                             authentication-success-handler-ref="AuthenticationSuccessHandler 객체를 상속 받아 Bean 으로 등록"
                             authentication-failure-handler-ref="AuthenticationFailureHandler 객체를 상속 받아 Bean으로 등록"
                             authentication-failure-url="로그인 실패시 URL 설정"
                             login-processing-url="	로그인 페이지 form action에 입력할 주소 지정"
                             />
        -->

        <security:logout/>
        <!--
        <security:logout
                logout-url="로그아웃 form 의 action url"
                logout-success-url="로그아웃 성공시 다음으로 보여질 url"
                success-handler-ref="로그아웃이 성공하면 AuthenticationSuccessHandler 객체를 상속 받아 response 객체 이용 가능"
                delete-cookies="true" 배우진 않았지만 token 제거가 아닌가 싶습니다.
                invalidate-session="true" 등록되어있는 모든 세션 제거
        -->
    </security:http>

    <security:authentication-manager>
        <security:authentication-provider>
            <!-- InMemory 방식 -->
            <security:user-service>
                <!-- name: userId (주의 이름이 아닌 아이디 입니다.) -->
                <!-- authorities : 권한, 등급 -->
                <!-- {noop} security의 특성상 비밀번호는 암호화 되어야 하는데, 암호화 를 안하겠다는 뜻 입니다. -->
                <security:user name="admin" password="{noop}admin" authorities="ROLE_ADMIN"/>
            </security:user-service>

            <!-- JDBC 방식 -->
            <!--
            <security:jdbc-user-service data-source-ref="DataSource 객체 주입"
            users-by-username-query="form 으로 넘어온 아이디와 비밀번호 확인을 위한 user table 조회 WHERE USERID = ?"
                                     "이때 주의점은 id는 username 으로 빼와야 하고 비밀번호는 password로 빼와야 합니다."
            authorities-by-username-query="유저의 아이디와 authority 컬럼의 권한을 조회 WHERE USERID = ?"
            />
            -->

            <security:password-encoder/>
            <!--
            <security:password-encoder ref="bcryptPasswordEncoder 객체를 사용하여 암호화 대조"
                                       "이때 주의점은 디비에도 bcryptPasswordEncoder 을사용 하여 insert한 비밀번호이여야 합니다."

             -->
            <!--
            <security:password-encoder ref="PasswordEncoder 객체를 상속받아 디비에 암호화 되어있는 비밀번호와"
                                       "사용자로부터 입력받은 비밀번호를 암호화 시켜서 대조"
            -->

        </security:authentication-provider>
    </security:authentication-manager>
    <!--  -->
    <!--  -->
    <!--  -->

</beans>
